- Overall
  - Unsupported syntax    
    - bit vectors    
    - reals, /, **, int(), real(), decimal/float litearls
    - call * := Q(x, y), call forall to a procedure with out-parameters
    - empty map domains x: []int    
    - code expression
  - Optimization: e.g. better data structures instead of lists  
  - Do not throw away attributes and triggers
  - Dynamic assertion (loop invariant) inference (testing + statistical test)?

- Type checker
  - Data type for type errors (will be easier to evaluate test results)
  - Use lenses for Context?
  - Annotate AST with expr types
  
- Interpreter
  - Check that Explies is supported everywhere
  - Fix control flow non-determinism (if(*) should generate two executions)
  - Check function and map constraints lazily
    - When checking map constraints replace the map name in the original constraint with something, because maps can escape their scope and more than one variable can be associated with the same reference
    - Currently function definitions written as bodies are not added as constraints (this e.g. leads to unsoundness in LinkedListTraversal without acyclicity constraints). Checking these constraints is costly (or non-terminating?) in case of resursive function, since their values are not cached.
    - Currently forall constraints for constants are ignored.
    - Map equality with overrides
      - check that values chosen for old sources conform to constraints (problem that we don't have types when choosing a value)
      - add non-equal guards to the new source 
    - Move definitions/constraints without guards to the front    
    - Eager bounded mode: do not check constraints if map index is beyond bounds?
    - Lazy mode: only enforce a constraint when all involved values are already defined (less consistent, but doesn't loop)
    - Infer constraints from axioms that mention a map update (using not-equals guard?)
  - Indexing by maps (so far only for functions)
  - Refactor executeLocally, execCall and execProcedure
  - Refactor evalVar, setAnyVar and so on, so that there is a unified meachism to lookup a name in the type context
  - Lazy initialization of arguments (in execLocally only copy those args that are already initialized, at the end propage the initizlization back with assume)
  - Lambda expressions
  - Turn source positions into spans; use the end of the span to report postcondition violations  
  - Extends ordering
  - Constraint solving
  - Call forall
    
- User interface
  - pass more information with failures other than spec violations, so that relevant variables can be determined
  - settings for disabling checking of different specs
  - interactive sessions
  - debugger
