- Overall
  - Create package and some doc (+ examples: sum_max, sorting/binary_search)
  - Unsupported syntax    
    - bit vectors    
    - reals, /, **, int(), real(), decimal/float litearls
    - call * := Q(x, y);
    - empty map domains x: []int    
    - code expression
  - Optimization: e.g. better data structures instead of lists  
  - Do not throw away attributes and triggers

- Type checker
  - Type constraint solving (HM?) to allow generic return types in functions
  - Annotate AST with expr types
  - Use state?
  
- Interpreter
  - First take on exhaustive/random testing (randomness/backtracking only in the outermost call)  
    - Filter invalid test cases (not re-check the precondition?)
    - Set relevant global variables
    - Handle polymorphic maps
    - Better test reports
    - Code duplication between testProgram and executeProgram
    - Can we do without creating new variables?
    - Random testing
  - Turn source positions into spans; use the end of the span to report postcondition violations  
  - User-defined types
  - Extends ordering
  - Extract function and constant constraints from axioms
  - Backtracking (logicT monad?)  
  - Constraint solving
  - Lambda expressions: cause problems with equality of Value (needed for evaluation of equality and for map acceses);
      forces to have "shalow" Eq, Ord on types and expressions, so that map values can be stored as map keys
      or to create a named function per lambda expression
  - Call forall
  - Make Value/Execution types generic (or at least eval and exec?). This will allow support for abstract interpretation and symbolic execution.    
  
- User interface
  - output local state with runtime error (restricted to the variables in the failed assertion)
  - allow entry points with in- and out-parameters
  - settings for disabling checking of different specs
  - settings for bounding domains to be checked in quantified expressions
  - interactive sessions  
