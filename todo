- Overall
  - Unsupported syntax    
    - bit vectors    
    - reals, /, **, int(), real(), decimal/float litearls
    - call * := Q(x, y), call forall to a procedure with out-parameters
    - empty map domains x: []int    
    - code expression
  - Optimization: e.g. better data structures instead of lists  
  - Do not throw away attributes and triggers
  - Dynamic assertion (loop invariant) inference (testing + statistical test)?

- Type checker
  - Encode polymorphic map types with DeBrujn indexes?
  - Data type for type errors (will be easier to evaluate test results)
  - Use lenses for Context?
  - Annotate AST with expr types
  
- Interpreter
  - Constraint extraction:    
    - Currently function definitions written as bodies are not added as constraints (this e.g. leads to unsoundness in LinkedListTraversal without acyclicity constraints). Checking these constraints is costly (or non-terminating?) in case of resursive function, since their values are not cached.    
    - Do not ignore forall constraints with non-simple arguments
    - Skolemize existentials
    - Move definitions/constraints without guards to the front    
    - Infer constraints from axioms that mention a map update (using not-equals guard?)
    - Do not ignore forall constraints for constants
    - Check if we need to normalize expressions before extracting constraints
  - Map representation  
    - Map equality with overrides
      - check that values chosen for old sources conform to constraints (problem that we don't have types when choosing a value)
      - add non-equal guards to the new source
    - Get rid of base-override representation and just use constraints?
    - Fix map inequality (currently unsound when a constraints says maps are equal)
    - Indexing by maps (so far only for functions)
  - Execution
    - Fix control flow non-determinism (if(*) should generate two executions)
    - Change backtracking model: introduce generateSuchThat, which would not generate assumption violation      
    - Add symbolic values not just for maps
    - Make some or all operations (e.g. assume) symbolic
  - Constraint solving  
  - Lambda expressions
  
  - Evaluation of quantification over types: is it worth to do it with brute force?
  - Refactor executeLocally, execCall and execProcedure (and saveOld/restoreOld?)
  - Refactor evalVar, setAnyVar and so on, so that there is a unified meachism to lookup a name in the type context
  - Lazy initialization of arguments (in execLocally only copy those args that are already initialized, at the end propage the initizlization back with assume)
  - Extends ordering
  - Turn source positions into spans; use the end of the span to report postcondition violations  
  - Call forall
    
- User interface
  - pass more information with failures other than spec violations, so that relevant variables can be determined
  - settings for disabling checking of different specs
  - interactive sessions
  - debugger: generated logs and traverse them?
